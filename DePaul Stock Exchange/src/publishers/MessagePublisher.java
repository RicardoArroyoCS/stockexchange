package publishers;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;

import users.User;
import messages.CancelMessage;
import messages.FillMessage;
import messages.MarketMessage;

public class MessagePublisher {
	
	private static MessagePublisher ourInstance;
	private  HashMap<String, HashSet<User> > userList = new HashMap<String,  HashSet<User> >();
	
	public static MessagePublisher getInstance() throws Exception {
		if (ourInstance == null)
			ourInstance = new MessagePublisher();

		return ourInstance;
	}

	public synchronized void unSubscribe(User u, String product) throws NotSubscribedException{
		HashSet<User> temp;	
		
		if (!userList.get(product).contains(u)) {
			throw new NotSubscribedException("User is not subscribed");
		} else {
			temp =  new HashSet<User>(userList.get(product));
			temp.remove(u);
			userList.put(product, temp);
		}
	}	
	
	public synchronized void subscribe(User u, String product) throws AlreadySubscribedException{
		HashSet<User> temp;		
		
		if(userList.containsKey(product) && userList.get(product).contains(u)) {
			throw new AlreadySubscribedException("User is already subscribed");
		}
		else {
			if(userList.containsKey(product)){
				temp =  new HashSet<User>(userList.get(product));
				temp.add(u);
				userList.put(product, temp);
			}
			else{
				temp = new HashSet<User>();
				temp.add(u);
				userList.put(product, temp);
			}
		}
	}
	
	public void printSubscribe(String product){
		System.out.println("Printing Subscrubed List");
		if(userList.get(product)!= null){
			for(User u : userList.get(product)){
				System.out.println(u.getUserName());
			}
		}
	}	
	
	public synchronized void publishCancel(CancelMessage cm){
		
//		-Find the individual User object in the HashSet or ArrayList for the specified stock symbol whose user
//		name matches the user name found in the CancelMessage object passed into �publishCancel�. The
//		user name and stock symbol are found in the provided CancelMessage.
//		
//		-Once found, call the User object�s �acceptMessage� passing the CancelMessage object that was
//		passed in.
		if(userList.get(cm.getProduct()) != null){
			HashSet<User> temp = new HashSet<User> (userList.get(cm.getProduct()));
			for(User u : temp){
				if(u.getUserName().equals(cm.getUser()))
					u.acceptMessage(cm);
			}

		}
	}
	
	public synchronized void publishFill(FillMessage fm){
		
//		-Find the individual User object in the HashSet or ArrayList for the specified stock symbol whose user
//		name matches the user name found in the FillMessage object passed into �publishFill�. The user
//		name and stock symbol are found in the provided FillMessage.
//		
//		-Once found, call the User object�s �acceptMessage� passing the FillMessage object that was passed
//		into �publishFill�
		if(userList.get(fm.getProduct()) != null){
			HashSet<User> temp = new HashSet<User> (userList.get(fm.getProduct()));
			for(User u : temp){
				if(u.getUserName().equals(fm.getUser()))
					u.acceptMessage(fm);
			}

		}
		
	}
	
	public synchronized void publishMarketMessage(MarketMessage mm){
		
//		-For all subscribed Users regardless of the stock symbol they are interested in, do the following:
//		---Call the User object�s �acceptMarketMessage� passing the String generated by calling the
//		   �toString� method of the MarketMessage object passed in.
		ArrayList<User> hasMessaged = new ArrayList<User>();
		for(HashSet<User> set : userList.values()){
			for(User u : set){
				if(!hasMessaged.contains(u)){
					u.acceptMarketMessage(mm.toString());
					hasMessaged.add(u);
				}
			}
		}
	/*	for(String key : userList.keySet()){
			for(User u : userList.get(key)){
				u.acceptMarketMessage(mm.toString());
			}
		} */
	}

}
